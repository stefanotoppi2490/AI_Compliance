# Cursor Rules â€” Contract Scope Guard (MVP)

## Project context
This repo is an MVP web app to upload a quote/contract (PDF/DOCX), run:
1) Contract Risk Analysis
2) Scope Check (is a client request in scope?)

Tech:
- Next.js App Router
- Tailwind CSS (UI inspired by Velvet template: Spruko Velvet TS)
- Custom auth (JWT + HttpOnly cookie)
- Postgres + Prisma
- Vercel Blob for file storage
- OpenAI: upload file + create Vector Store + file_search tool

IMPORTANT product constraints:
- One active document per project (Document.isActive = true)
- No text extraction, no chunking, no doc parsing pipelines
- The app passes the document directly to OpenAI through stored `openaiFileId` and/or `vectorStoreId`
- Risk Analysis and Scope Check results are persisted and shown in UI history

## Golden rules (never break)
- Never implement multiple alternative architectures. Follow existing patterns only.
- Do not add additional DB tables unless explicitly requested.
- Do not introduce background jobs/queues for MVP.
- Never change route shapes unless asked.
- All AI outputs must be reliably renderable in UI:
  - Always include a human-friendly `markdown` (no code fences)
  - And a structured JSON payload for persistence
- All API routes must enforce:
  - user ownership of project
  - presence of active document
  - Document.status === AI_READY
- Never parse PDF/DOCX content locally.

## Folder conventions
Use these paths exactly:
- `src/app/(auth)/login/page.tsx`
- `src/app/(auth)/register/page.tsx`
- `src/app/(app)/dashboard/page.tsx`
- `src/app/(app)/projects/[projectId]/page.tsx`  (Project detail)
- `src/app/api/...` for route handlers
- `src/lib/auth/*` auth utilities
- `src/lib/openai/*` OpenAI client & helpers
- `src/lib/http/clientFetch.ts` for client requests
- `src/lib/db/prisma.ts` Prisma client

UI components:
- Prefer local small components inside the page file for MVP.
- Use Tailwind classes consistent with Velvet-like design:
  - rounded-2xl cards
  - zinc palette
  - soft borders (`border-zinc-200`)
  - button styles: black primary / white secondary

## Prisma schema rules
Models already exist and must remain consistent:
- User(email unique, password bcrypt hash)
- Project(ownerId FK)
- Document(projectId, blobUrl, mimeType, originalName, openaiFileId?, vectorStoreId?, isActive, status)
- RiskAnalysis(projectId, documentId, inputMeta Json?, result Json)
- ScopeCheck(projectId, documentId, request string, result Json)

When editing relations:
- Always include both sides of relations (avoid Prisma validation errors)
- Keep indexes as they are (ownerId index; projectId+createdAt; etc.)

## Auth rules
Auth is custom:
- JWT stored in HttpOnly cookie
- `requireUser()` used by API routes
- If user not authenticated -> return 401 JSON (or redirect on pages)
- Dashboard and app pages must redirect to login if not authenticated

Never introduce NextAuth.

## API design (must match current approach)
Endpoints:
- Documents:
  - GET  `/api/projects/:projectId/documents` -> list
  - POST `/api/projects/:projectId/documents` -> create + set AI_READY (upload file to OpenAI + create vector store + attach + poll)
- Risk:
  - GET  `/api/projects/:projectId/risk-analysis` -> list latest 20
  - POST `/api/projects/:projectId/risk-analysis` -> run AI using file_search (vector_store_ids)
- Scope:
  - GET  `/api/projects/:projectId/scope-check` -> list latest 20
  - POST `/api/projects/:projectId/scope-check` -> run AI using file_search (vector_store_ids)

Strict enforcement:
- Each POST must use the active document (`isActive: true`)
- If doc not AI_READY -> 400 with message `Document not AI_READY (...)`

## OpenAI rules (critical)
We use OpenAI Node SDK via `openai.responses.create`.

Two valid strategies:
A) file_search via vector store (preferred because it works with PDF/DOCX after indexing)
B) direct input_file (but DOCX may fail for context stuffing). Avoid mixing unless required.

For this app, prefer vector store everywhere for robustness.

### File preparation flow (must exist)
When a document is created:
- fetch(blobUrl)
- openai.files.create({ file: fetchResponse, purpose: "user_data" })
- openai.vectorStores.create(...)
- openai.vectorStores.files.create(vectorStoreId, { file_id })
- poll until status === "completed"
- store:
  - `openaiFileId`
  - `vectorStoreId`
  - `vectorStoreFileId` (if present in schema)
  - set `status = AI_READY`

If anything fails:
- set `status = ERROR`
- return 500 with error message

### Output formats
Risk Analysis MUST return strict JSON schema:
- `reportMarkdown: string` (Italian, headings & bullets, no fences)
- `data: { overallRisk, issues[], missingClauses[], notes }`

Scope Check MUST return strict JSON schema:
- `verdict`
- `confidence`
- `markdown` (Italian, readable summary for UI, no fences)
- `reasons[]` with `evidence`
- `missingInfo[]` with `evidence`
- `suggestedReply`

Always use `text.format.json_schema` with `strict: true` when possible.

### Response extraction
Never rely only on `resp.output_text`.
Use project helper:
- `getResponseText(resp)` that aggregates output safely.

## Frontend rules
Use React Query for all server calls:
- query keys must be stable and namespaced
- after mutations, invalidate correct keys

Project Detail page requirements:
- upload PDF/DOCX to Vercel Blob
- POST create document
- show active doc card + upload history
- Risk card:
  - button run
  - render `reportMarkdown` nicely (not JSON dump)
  - show JSON details collapsed or in a <details>
- Scope card:
  - textarea request
  - render `markdown` nicely
  - show JSON details collapsed

Rendering markdown:
- For MVP, render as `<pre>` or simple markdown renderer if already installed.
- No code fences should appear in stored markdown.

## Error handling
All API routes:
- return `{ ok:false, error:"..." }` with proper status codes
- never leak stack traces to client responses
- log server-side with `console.error` including `resp.id` when OpenAI fails

Client:
- show errors in red card
- disable actions while pending
- prevent running Risk/Scope if no active document

## What to do when asked to implement a change
Always follow this checklist:
1) Identify existing file paths and patterns
2) Implement minimal change consistent with current architecture
3) Ensure Prisma relations compile
4) Ensure routes return correct status codes
5) Ensure UI invalidates queries correctly

Do not propose big refactors unless asked.